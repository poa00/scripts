#!/usr/bin/env perl -w
#
# @(#) cvsstat.pl -- Convert 'cvs stat' output to revision tree notation
# @(#) $Id: cvsstat.pl,v 1.2 2002/07/27 07:39:27 jaalto Exp $
#
#  File id
#
#       .Copyright (C)  2002 Jari Aalto
#       .$Contactid: jari.aalto@poboxes.com $
#       .Created:       2002-07
#       .Keywords:      Perl
#       .Perl:          5.004
#
#       This program is free software; you can redistribute it and/or
#       modify it under the terms of the GNU General Public License as
#       published by the Free Software Foundation; either version 2 of
#       the License, or (at your option) any later version.
#
#       This program is distributed in the hope that it will be useful, but
#       WITHOUT ANY WARRANTY; without even the implied warranty of
#       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#       General Public License for more details.
#
#       You should have received a copy of the GNU General Public License along
#       with this program; if not, write to the Free Software Foundation,
#       Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
#   About program layout
#
#       The {{ }}} marks you see in this file are party of file "fold"
#       conrol package called folding.el (Unix Emacs lisp package).
#       ftp://ftp.csd.uu.se/pub/users/andersl/beta/ to get the latest. m/
#       There is also lines that look like # ....... &tag ... and they
#       are generated by Emacs Lisp package tinybm.el.
#
#   Funny identifiers at the top of file
#
#       The GNU RCS ident(1) program can print usefull information out
#       of all variables that are in format $ IDENTIFIER: text $
#       See also Unix man pages for command what(1) which outputs all lines
#       matching @( # ). Try commands:
#
#           % what  PRGNAME
#           % ident PRGNAME
#
#   Description
#
#       Call program with --help
#
#   End



BEGIN { require 5.004 }

use autouse 'Pod::Text'     => qw( pod2text );
use autouse 'Pod::Html'     => qw( pod2html );

use strict;
use English;
use Cwd;
use Getopt::Long;

    use vars qw ( $VERSION );

    #   This is for use of Makefile.PL and ExtUtils::MakeMaker
    #   So that it puts the tardist number in format YYYY.MMDD
    #   The REAL version number is defined later

    #   The following variable is updated by my Emacs setup whenever
    #   this file is saved

    $VERSION = '2002.0727';

# {{{ Initial setup

# ****************************************************************************
#
#   DESCRIPTION
#
#       Set global variables for the program
#
#   INPUT PARAMETERS
#
#       none
#
#   RETURN VALUES
#
#       none
#
# ****************************************************************************

sub Initialize ()
{
    use vars qw
    (
        $PROGNAME
        $LIB
        $FILE_ID
        $VERSION
        $CONTACT
        $URL
        $WIN32
    );

    $PROGNAME   = "cvsstat.pl";
    $LIB        = $PROGNAME;
    my $id      = "$LIB.Initialize";

    $FILE_ID  = q$Id: cvsstat.pl,v 1.2 2002/07/27 07:39:27 jaalto Exp $; #font m/
    $VERSION  = (split (' ', $FILE_ID))[2];
    $CONTACT  = "<jari.aalto\@poboxes.com>";
    $URL      = "http://poboxes.com/jari.aalto/";

    $WIN32    = 1   if  $OSNAME =~ /win32/i;
    $OUTPUT_AUTOFLUSH = 1;

    # not defined $HOME  and  die "$id: No HOME.";

}



# }}}



# ***************************************************************** &help ****
#
#   DESCRIPTION
#
#       Print help and exit.
#
#   INPUT PARAMETERS
#
#       $msg    [optional] Reason why function was called.-
#
#   RETURN VALUES
#
#       none
#
# ****************************************************************************

=pod

=head1 NAME

cvsstat.pl - Convert 'cvs stat -v' output to revision tree notation

=head1 README

CVS is a version control software available at http://www.cvshome.org/. On
of its many commands is C<cvs stat -v FILE> which prints the revision and tag
information. This program converts C<cvs stat -v> output to a more
readable revision hierarchy tree.

      branch
        revision
        revision
        branch
          revision
          revision
        revision
      branch
        revision
        revision
        revision

=head1 SYNOPSIS

    cvsstat.pl --help
    cvsstat.pl --file cvs-file.txt
    cvs stat -v cvs-file.txt | cvsstat.pl
    cvs stat -v cvs-file.txt | cvsstat.pl --brief

=head1 OPTIONS

=head2 Gneneral options

=over 4

=item B<--brief -b>

Print only revision tree. Suppress header printing.

=item B<--cvs -c>

Instead of reading the output, call C<cvs stat -v> directly and format
the output. This is like doing

    bash$ cvs stat -v file.txt  => cvsstat.pl --file file.txt

=item B<--file -f FILE [FILE ..] >

Run C<cvs stat -v> on FILE and then format the output. If you have operating
system (non-Win32), which allows making aliases, you could do a shortcut:

    bash$ alias cvss="cvsstat.pl --file"
    tcsh$ alias cvss 'cvsstat.pl --file \!*"

After that, these two were equivalent:

    bash$ cvs stat -v cvs-file.txt
    bash$ cvss cvs-file.txt

Remember to have this line in your $HOME/.cvsrc, which prepends always
option C<-v> to the status command.

    status -v

=back

=head2 Miscellaneous options

=over 4

=item B<--debug [LEVEL]>

Turn on debug with positive LEVEL number. Zero means no debug.

=item B<--help>

Print help

=item B<--help-html>

Print help in HTML format.

=item B<--help-man>

Print help page in Unix manual page format. You want to feed this output to
B<nroff -man> in order to read it.

=item B<--test>

Run in test mode, do not actually do anything.

=item B<--verbose>

Print informational messages.

=item B<--Version>

Print contact and version information

=back

=head1 DESCRIPTION

The C<cvst stat> output looks like this:

    bash$ cvs stat -v test.txt

    File: 1                 Status: Up-to-date

       Working revision:    1.1.1.1.2.1     Wed Jul 24 11:37:14 2002
       Repository revision: 1.1.1.1.2.1     /cvstroot/test/test.txt,v
       Sticky Tag:          my-1 (branch: 1.1.1.1.2)
       Sticky Date:         (none)
       Sticky Options:      (none)

       Existing Tags:
            b2                              (revision: 1.1.1.2)
            vendor-v2                       (branch: 1.1.1.1.2)
            b1                              (revision: 1.1.1.1)
            vendor-v1                       (branch: 1.1.1)

As you can see, this file contains two kinds of tags (labels): branches and
revisions. Conceptually the development line above can be expressed as:

    vendor-v1   (First import: "cvs import code/tree/here net vendor-v1")
    |
    +-b1        (Branch of it: "cvs tag -b b1; cvs up -r b1")

    vendor-v2   (Second import)
    |
    +-v2        (Branch of it)

The above is a typical situation when tracking third party changes. A user
started the project by downloading vendor's software and importing it into
CVS tree (vendor-v1). In order to make private changes to the code, a
branch was created (b1). Later a new release appeared and the vendor code
was again imported to the tree (vendor-v2) followed by a working branch for
private changes (v2).

Now, as the development continues, there will be many more branches and
imports and soon it will be hard to grasp how does the development tree
look like. The obvious question it: what tags should I use to merge the
changes forward when I don't understand the revision hierarchy? In order to
make the decisions, this script will help by converting the output to more
readable format. Like this:

    bash$ cvs stat -v test.txt | cvsstat.pl

    File: 1                 Status: Up-to-date

       Working revision:    1.1.1.1.2.1     Wed Jul 24 11:37:14 2002
       Repository revision: 1.1.1.1.2.1     /cvstroot/test/test.txt,v
       Sticky Tag:          my-1 (branch: 1.1.1.1.2)
       Sticky Date:         (none)
       Sticky Options:      (none)

       Existing Tags:
             1.1.1 branch vendor-v1
               1.1.1.1 revision b1
                 1.1.1.1.2 branch my-1
               1.1.1.2 revision vendor-v2

A more complicated tree layout would look like below. Here the vendor code
(fsf) has been imported 3 times with release revision numbers: 20.6, 20.7.3
and 21.1. Since tag name cannot contain dots, dashes were used instead. If
the revisions look familiar to you, they are Emacs
C<http://www.gnu.org/software/emacs/emacs.html> releases and local changes
to the lisp modules.

    bash$ cvs stat -v anther-test.txt | cvsstat.pl --brief

         1.1.1 branch fsf
           1.1.1.1 revision v20-6
             1.1.1.1.2 branch b20-6
               1.1.1.1.2.1 revision b20-6-change-one-2000-12-14
               1.1.1.1.2.2 revision b20-6-change-one-2001-01-01
               1.1.1.1.2.3 revision b20-6-change-one-2001-01-02
               1.1.1.1.2.4 revision b20-6-change-one-2001-01-02
               1.1.1.1.2.5 revision b20-6-change-one-2001-01-04
                 1.1.1.1.2.5.2 branch b20-6-w32-change-two
                 1.1.1.1.2.5.4 branch b20-6-w32-change-three
                 1.1.1.1.2.5.6 branch b20-6-w32-change-four
             1.1.1.1.4 branch b20-6-special
             1.1.1.1.6 branch b20-6-w32-input-reader
             1.1.1.1.8 branch b20-6-w32-telnet
             1.1.1.1.10 branch b20-6-w32-telnet
             1.1.1.1.12 branch b20-6-w32-telnet2
             1.1.1.1.14 branch b20-6-merge-2001-01-04
               1.1.1.1.14.1 revision b20-6-merge-2000-01-07
             1.1.1.1.16 branch b20-6-w32-protocol
             1.1.1.1.18 branch b20-6-autosave
             1.1.1.1.20 branch b20-6-w32-spell
           1.1.1.2 revision v20-7-3
           1.1.1.3 revision v21-1
             1.1.1.3.2 branch b21-1-merge-2000-01-15


If your're wondering how you would keep track of 3rd party software easily
(easier than that of above), here is simple procedure. The vendor tag
chosen here is C<net> for all the code that you download from Internet. You
could use tags like C<fsf>, C<apache>, C<sun> etc., but it's easier to
stick one name that covers them all: the C<net>.

    1. Unpack to fresh place. Go to unpack directory

        cvs import -m "version 20.6" code/dir net v20-6

    2. Check out fresh copy

        cvs co -d v20-6 code/dir

    3. Prepare you local changes by creating a branch

        cvs tag -b b20-6

    4. Change to branch and start working with your local changes

        cvs up -r b20-6

When new release appears, re-iterate from point (1). The only thing left is
to move your changes to the latest release. After step (4), you simply need
join:

       cvs up -j b20-6

This assumes that you never go back to 20.6 and change it's code any
more. If you need to do that, then things get much more ocmplicated and
you have to tag file before the merge and after the merge. Uhm, that's
another story. Refer to on-line CVS book at C<cvsbook.red-bean.com/>

=head1 EXAMPLES

See program call conventions.

=head1 TROUBLESHOOTING

Use --debug to pinpoint the problem. If you the output does not
make sense, copy C<cvs stat -v> output and send it to the maintainer
with your comments.

=head1 ENVIRONMENT

No environment variables used.

=head1 FILES

No files created.

=head1 SEE ALSO

cvs(1) cvsweb(1) rcs(1)

=head1 STANDARDS

<RFCs, ANSI/ISO, www.w3c.org that are related>

=head1 BUGS

None known.

=head1 AVAILABILITY

Project home page is at http://cvs-tools.sourceforge.net/
Reach author at jari.aalto@poboxes.com

=head1 SCRIPT CATEGORIES

CPAN/Administrative

=head1 PREREQUISITES

Only standard Perl modules used.

=head1 COREQUISITES

Only standard Perl modules used.

=head1 OSNAMES

C<any>

=head1 VERSION

$Id: cvsstat.pl,v 1.2 2002/07/27 07:39:27 jaalto Exp $

=head1 AUTHOR

Copyright (C) 2002 Jari Aalto. All rights reserved.
This program is free software; you can redistribute and/or modify program
under the same terms as Perl itself or in terms of Gnu General Public
license v2 or later.

=cut


sub Help (;$$)
{
    my $id   = "$LIB.Help";
    my $msg  = shift;  # optional arg, why are we here...
    my $type = shift;  # optional arg, type

    if ( $type eq -html )
    {
        pod2html $PROGRAM_NAME;
    }
    elsif ( $type eq -man )
    {
        eval "use Pod::Man";
        $EVAL_ERROR  and  die "$id: Cannot generate Man: $EVAL_ERROR";

        my %options;
        $options{center} = 'cvs status - formatter';

        my $parser = Pod::Man->new(%options);
        $parser->parse_from_file ($PROGRAM_NAME);
    }
    else
    {
        pod2text $PROGRAM_NAME;
    }

    defined $msg  and  print $msg;

    exit 1;

}


# ************************************************************** &args *******
#
#   DESCRIPTION
#
#       Read and interpret command line arguments ARGV. Sets global variables
#
#   INPUT PARAMETERS
#
#       none
#
#   RETURN VALUES
#
#       none
#
# ****************************************************************************

sub HandleCommandLineArgs ()
{
    my    $id = "$LIB.HandleCommandLineArgs";

    use vars qw
    (
        $debug
        $verb
        $test
        $OPT_BRIEF
        $OPT_FILE
    );


    my ( $version, $help, $helpHTML, $helpMan );

    # .................................................... read args ...

    Getopt::Long::config( qw
    (
        no_ignore_case
        require_order
    ));

    GetOptions      # Getopt::Long
    (
          "h|help"              => \$help
        , "help-html"           => \$helpHTML
        , "help-man"            => \$helpMan
        , "verbose"             => \$verb
        , "Version"             => \$version
        , "debug:i"             => \$debug
        , "test"                => \$test

        , "brief"               => \$OPT_BRIEF
        , "file"                => \$OPT_FILE

    );

    $version        and  die "$VERSION $PROGNAME $CONTACT $URL\n";
    $help           and  Help();
    $helpHTML       and  Help undef, -html;
    $helpMan        and  Help undef, -man;

    $debug = 1      if  defined $debug  and  $debug == 0;
    $verb  = 1      if  $debug;
    $verb  = 1      if  $test;

}



# ****************************************************************************
#
#   DESCRIPTION
#
#       Parse the "cvs stat -v" output to machine format. Like
#
#          Existing Tags:
#              b21-1                           (branch: 1.1.1.2.2)
#              v21-1                           (revision: 1.1.1.2)
#
#   INPUT PARAMETERS
#
#       $ARG contains the full cvs output.
#
#   RETURN VALUES
#
#       This function return a list structure of anonymous arrays.
#
#           @ret = ( ARRAY, ARRAY, ARRAY )
#
#       Each array contains entry:
#
#           [ "b21-1", "branch", "1.1.1.2.2" ]
#
#
# ****************************************************************************

sub Parse ( $ )
{
    my $id  = "$LIB.Tags";
    local( $ARG ) = @ARG;

    #  Kill all until this.

    s/.*?Existing Tags://ism;

    my ( @ret);

#    while ( ($tag, $type, $ver) = /^ +(\S+)[ \t]+\(([^ \t:]+): +([\d.]+)/sm  )

    my $tagRegexp  = '[\t ]+(\S+)';
    my $typeRegexp = '[ \t]+\(([^ \t:]+):';
    my $verRegexp  = ' +([\d.]+)';

    while (  /^$tagRegexp$typeRegexp$verRegexp/gmo  )
    {
        my ($tag, $type, $ver) = ( $1, $2, $3 );

        $debug  and  print "$id: $tag, $type, $ver\n";

        push @ret, [ $tag, $type, $ver ];
    }

    @ret;
}

{
    my $staticMax = 0;


# ****************************************************************************
#
#   DESCRIPTION
#
#       Standardize verion number so that it can be sorted easily.
#       Each version number token is constructed to hold 16 numbers,
#       and filled with leading zeroes. This means that given version
#       number 1.1, it would be converted into:
#
#           ===============1.===============1.
#           ^                                 ^
#           ^                                 This continues x 16 times
#           Each of these "=" represents a number "0".
#
#   INPUT PARAMETERS
#
#       $ARG    Version number string. Like 1.1, 1.1.1, 2.5.6.7
#
#   RETURN VALUES
#
#       $key    Canonical version number.
#
# ****************************************************************************

sub VersionStandardize ( $ )
{
    my $id       = "$LIB.VersionStandardize";
    local $ARG   = shift;

    my $key = "";
    my @v   = /(\d+)/g ;

    if ( /([a-z])$/ )   #   "1.1a"
    {
        #  1.1a  => 1.1.97  ,use ascii code
        #  1.1   => 1.1.0

        push @v, ord $1;        # get character ASCII code
    }


    $debug  and  print "$id: [Version] \@v = @v\n";

    #   Record how many separate digits we found.

    $staticMax = @v         if @v > $staticMax;

    #   fill until 16 version digit elements in array

    push @v, 0      while @v < 16 ;

    for my $version ( @v )
    {
        #       1.0 --> 0001.0000.0000.0000.0000.0000
        $key .= sprintf "%016d.", $version;
    }

    $key;
}}


# ****************************************************************************
#
#   DESCRIPTION
#
#       Make searchable hash, keyed by canonical version number.
#
#   INPUT PARAMETERS
#
#       @list = ( ARRAY, ARRAY, ARRAY )
#
#       ehere each array contains entry:
#
#           [ "b21-1", "branch", "1.1.1.2.2" ]
#
#   RETURN VALUES
#
#       Hash, where eask KEY is canonical version number and VALUE is
#       an anonymous array.
#
#           %hash = { HASH-KEY, ARRAY }
#
#       Each HASH-KEY is unique. See VersionStandardize().
#       Each ARRAY is like the one at Parse().
#
# ****************************************************************************

sub HashBuild ( @ )
{
    my $id  = "$LIB.HashBuild";
    my( @list ) = @ARG;

    my %hash;

    for my $entry ( @list )
    {
        my ($tag, $type, $ver) = @$entry;
        my $canonical = VersionStandardize $ver;

        # associate info for standard version number

        $hash{ $canonical } = $entry;

        $debug > 1 and  print "$id: $canonical => [$tag $type $ver]\n";
    }

    %hash;
}

# ****************************************************************************
#
#   DESCRIPTION
#
#       Print Tree like strycture of all version numbers in hash.
#       Output is intended according to how many numbers there are in
#       version number.
#
#             1.1.1 branch fsf
#               1.1.1.1 revision v20-6
#                 1.1.1.1.2 branch b20-6
#
#   INPUT PARAMETERS
#
#       $prefix     is string printed in front of output.
#
#       %hash = { HASH-KEY, ARRAY }
#
#       Each HASH-KEY is unique. See VersionStandardize().
#       Each ARRAY is like the one at Parse().
#
#   RETURN VALUES
#
#       none
#
# ****************************************************************************


sub PrintTree ( % )
{
    my $id  = "$LIB.PrintTree";
    my( $prefix, %hash ) = @ARG;

    for my $key ( sort keys %hash )
    {
        my ($tag, $type, $ver) = @{ $hash{$key} };

        my $dots = 0;

        $dots++ while $ver =~ /\./g;

        my $indent = "";

        if ( $dots > 1 )
        {
            $indent = "  " x $dots;
        }

        printf "%s%s$ver $type $tag\n", $prefix, $indent;
    }

}


# ****************************************************************************
#
#   DESCRIPTION
#
#       Print header of "cvs stat -v". All up till string "Existing Tags:"
#
#       ===================================================================
#       File: comint.el         Status: Locally Modified
#
#          Working revision:    1.1.1.1.2.5     Result of merge
#          Repository revision: 1.1.1.1.2.5     /cvsroot/test/foo.txt,v
#          Sticky Tag:          b20-6 (branch: 1.1.1.1.2)
#          Sticky Date:         (none)
#          Sticky Options:      (none)
#
#          Existing Tags:
#
#   INPUT PARAMETERS
#
#       $ARG        Output of cvs
#
#   RETURN VALUES
#
#       none
#
# ****************************************************************************

sub PrintHeader ( $ )
{
    my $id  = "$LIB.PrintHeader";
    local( $ARG ) = @ARG;

    #  Kill all until this.

    s/(.*?Existing Tags:)(.*)/$1\n/ism;

    print;
}
# ****************************************************************************
#
#   DESCRIPTION
#
#       Parse one "cvs stat -v" output.
#
#   INPUT PARAMETERS
#
#       $input      one string containing all lines.
#
#   RETURN VALUES
#
#       None. Result is written to stdout
#
# ****************************************************************************

sub HandleInput ($)
{
    my $id      = "$LIB.HandleInput";
    my ($input) = @ARG;

    my @info = Parse $input;
    my %hash = HashBuild @info;

    ! $OPT_BRIEF and PrintHeader $input;

    #  CVS prints TAB character in from of every version line, so we add
    #  one too to be just like CVS uoutput.
    #
    #      Existing Tags:
    #               b21-1                           (branch: 1.1.1.2.2)
    #      ^
    #      TAB Character here

    my $str = "\t";

    $OPT_BRIEF  and  $str = "";

    PrintTree $str, %hash;

}

# ************************************************************** &main *******
#
#   DESCRIPTION
#
#       Parse "cvs stat -v file.txt" output
#
#   INPUT PARAMETERS
#
#       none
#
#   RETURN VALUES
#
#       $date
#
# ****************************************************************************


sub Main ()
{
    Initialize();
    HandleCommandLineArgs();

    my $id  = "$LIB.Main";

    if ( $OPT_FILE )
    {
        die "$id: Missing filenames to 'cvs stat -v'" unless @ARGV;

        for my $file ( @ARGV )
        {
            my $input = qx(cvs status -v $file);
            HandleInput $input;
        }
    }
    else
    {
        #  Read ouput of "cvs stat -v file.cc | cvsstat.pl"
        my $input = join '', <>;

        HandleInput $input;
    }

}

Main();

0;
__END__
